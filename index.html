<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>14 De Febrero ‚ú®</title>
  <style>
    *{ margin:0; padding:0; box-sizing:border-box; }
    html, body{
      width:100%;
      height:100%;
      overflow:hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 800px at 70% 20%, #0a0f2a, #02030a);
      color:#fff;
    }
    #scene{ position: fixed; inset:0; width:100%; height:100%; display:block; }
    .hint{
      position: fixed;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 5;
      pointer-events:none;
      font-size: 12px;
      color: rgba(255,255,255,0.55);
      text-shadow: 0 0 12px rgba(0,0,0,0.65);
      text-align:center;
      padding: 0 12px;
      line-height: 1.3;
    }
    .vignette{
      position: fixed;
      inset: 0;
      pointer-events:none;
      background: radial-gradient(circle at center, rgba(0,0,0,0) 45%, rgba(0,0,0,0.55) 100%);
    }

    /* ---------------------------
       UI Buttons
    --------------------------- */
    .ui{
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }

    .ui .panel{
      pointer-events: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 10px;
      border-radius: 16px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 35px rgba(0,0,0,0.35);
    }

    .ui button{
      appearance: none;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.22);
      color: rgba(255,255,255,0.92);
      padding: 10px 12px;
      border-radius: 14px;
      font-size: 12px;
      letter-spacing: 0.2px;
      cursor: pointer;
      transition: transform 0.08s ease, background 0.15s ease, border 0.15s ease;
      user-select: none;
    }

    .ui button:active{ transform: scale(0.97); }

    .ui button:hover{
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.18);
    }

    .ui .row{
      display: flex;
      gap: 8px;
    }
    .ui .row button{ flex: 1; }

    .badge{
      pointer-events: none;
      font-size: 11px;
      opacity: 0.7;
      text-align: center;
      padding-top: 4px;
    }

    /* Bot√≥n TE AMO (destacado) */
    #loveBtn{
      border: 1px solid rgba(255, 120, 190, 0.35);
      background: rgba(255, 90, 170, 0.14);
    }
    #loveBtn:hover{
      background: rgba(255, 90, 170, 0.22);
      border: 1px solid rgba(255, 120, 190, 0.50);
    }

    @media (max-width: 520px){
      .ui{
        right: 10px;
        bottom: 10px;
      }
      .ui button{
        padding: 10px 10px;
        font-size: 12px;
      }
    }
  </style>
</head>

<body>
  <div class="hint">
    Arrastra para rotar<br>
    (y haz zoom con scroll o pellizco)
  </div>

  <canvas id="scene"></canvas>
  <div class="vignette"></div>

  <!-- UI Buttons -->
  <div class="ui">
    <div class="panel">
      <div class="row">
        <button id="zoomIn">Zoom +</button>
        <button id="zoomOut">Zoom -</button>
      </div>

      <button id="resetView">Centrar ‚ú®</button>
      <button id="toggleAuto">Auto: ON</button>

      <button id="loveBtn">TE AMO üíó</button>

      <div class="badge" id="statusText">Modo suave üåô</div>
    </div>
  </div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    const canvas = document.getElementById("scene");

    const PHRASES = [
      "Eres mi lugar favorito en el universo",
      "Contigo, todo se siente posible",
      "Tu risa es mi constelaci√≥n favorita",
      "Si me pierdo, que sea en tus ojos",
      "Te elegir√≠a incluso sin destino",
      "Tu voz se siente hogar",
      "Siempre t√∫, en todas partes",
      "Eres mi paz con luces",
      "Si es contigo, s√≠",
      "Qu√© bonito encontrarte",
      "Mi universo tiene tu nombre",
      "Te pienso bonito",
      "Eres mi estrella fija",
      "Eres la calma que no sab√≠a pedir",
      "Me gustas en todos los idiomas",
      "Contigo, el tiempo se vuelve suave",
      "T√∫ eres mi mejor casualidad",
      "Eres mi s√≠ m√°s bonito",
      "Me encanta tu existencia",
      "Tu mirada tiene magia",
      "Eres mi canci√≥n favorita",
      "Yo te elijo, sin prisa",
      "Te quiero cerca, siempre",
      "Eres un abrazo en forma de persona",
      "Contigo todo se siente m√°s bonito",
      "Eres mi suerte favorita",
      "Tu amor me queda perfecto",
      "Eres luz cuando todo se apaga",
      "Me haces creer en lo bonito",
      "Eres mi galaxia favorita",
      "Me gustas m√°s de lo que digo",
      "Eres mi lugar seguro",
      "Contigo no me pierdo",
      "Eres mi constelaci√≥n",
      "Tu nombre suena a hogar",
      "Me haces sonre√≠r sin darme cuenta",
      "Eres mi paz favorita",
      "T√∫ y yo, siempre",
      "Me encanta tu forma de existir",
      "Si es contigo, vale todo",
      "Eres mi estrella m√°s brillante",
      "Me haces sentir en casa",
      "Eres mi mejor amiga",
      "T√∫ eres mi universo",
      "Te quiero bonito",
      "Me gustas sin medida",
      "Eres mi destino favorito",
      "Eres mi magia diaria",
      "Tu amor se siente infinito",
      "Eres mi cielo personal",
      "Somos colegas para siempre",
    ];

    // ---------------------------
    //  FOTO SPRITES (tus im√°genes)
    // ---------------------------
    const PHOTO_URLS = [
      "img/1.png",
      "img/2.png",
      "img/3.png",
      "img/4.png",
      "img/5.png",
      "img/6.png",
      "img/7.png",
      "img/9.png",
      "img/10.png",
      "img/11.png",
      "img/12.png",
      "img/13.png",
      "img/14.png",
      "img/15.png",
      "img/16.png",
      "img/17.png",
    ];

    // ---------------------------
    //  Three.js setup
    // ---------------------------
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 4000);
    camera.position.set(0, 10, 150);

    scene.add(new THREE.AmbientLight(0xffffff, 1));

    const galaxy = new THREE.Group();
    scene.add(galaxy);

    // ---------------------------
    //  Stars
    // ---------------------------
    const STAR_COUNT = 2400;
    const positions = new Float32Array(STAR_COUNT * 3);
    const colors = new Float32Array(STAR_COUNT * 3);

    for(let i=0; i<STAR_COUNT; i++){
      const i3 = i * 3;

      const r = Math.pow(Math.random(), 0.58) * 220;
      const angle = Math.random() * Math.PI * 2;
      const spin = r * 0.05;
      const y = (Math.random() - 0.5) * 28;

      const x = Math.cos(angle + spin) * r;
      const z = Math.sin(angle + spin) * r;

      positions[i3 + 0] = x;
      positions[i3 + 1] = y;
      positions[i3 + 2] = z;

      colors[i3 + 0] = 0.78 + Math.random() * 0.22;
      colors[i3 + 1] = 0.85 + Math.random() * 0.15;
      colors[i3 + 2] = 0.88 + Math.random() * 0.12;
    }

    const starGeo = new THREE.BufferGeometry();
    starGeo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    starGeo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

    const starMat = new THREE.PointsMaterial({
      size: 1.0,
      vertexColors: true,
      transparent: true,
      opacity: 0.95,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const starPoints = new THREE.Points(starGeo, starMat);
    galaxy.add(starPoints);

    // Nebula glow (vamos a animar su color/opacidad con TE AMO)
    const fogGeo = new THREE.SphereGeometry(320, 32, 32);
    const fogMat = new THREE.MeshBasicMaterial({
      color: 0x4a86ff,
      transparent: true,
      opacity: 0.05,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide
    });
    const fogMesh = new THREE.Mesh(fogGeo, fogMat);
    scene.add(fogMesh);

    // ---------------------------
    //  Text Sprites (phrases)
    // ---------------------------
    function roundRect(ctx, x, y, w, h, r){
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }

    function makeTextSprite(message){
      const c = document.createElement("canvas");
      const ctx = c.getContext("2d");

      const fontSize = 22;
      ctx.font = `600 ${fontSize}px Arial`;

      const paddingX = 16;
      const paddingY = 10;
      const textWidth = ctx.measureText(message).width;

      c.width = Math.ceil(textWidth + paddingX * 2);
      c.height = Math.ceil(fontSize + paddingY * 2);

      ctx.font = `600 ${fontSize}px Arial`;

      ctx.fillStyle = "rgba(255,255,255,0.035)";
      roundRect(ctx, 0, 0, c.width, c.height, 14);
      ctx.fill();

      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 2;
      roundRect(ctx, 1, 1, c.width-2, c.height-2, 14);
      ctx.stroke();

      ctx.fillStyle = "rgba(255,255,255,0.90)";
      ctx.textBaseline = "middle";
      ctx.fillText(message, paddingX, c.height/2);

      const texture = new THREE.CanvasTexture(c);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;

      const material = new THREE.SpriteMaterial({
        map: texture,
        transparent: true,
        opacity: 0.85,
        depthWrite: false
      });

      const sprite = new THREE.Sprite(material);

      const base = 0.055;
      sprite.scale.set(c.width * base, c.height * base, 1);

      return sprite;
    }

    const phraseGroup = new THREE.Group();
    galaxy.add(phraseGroup);

    PHRASES.forEach((text, idx) => {
      const sprite = makeTextSprite(text);

      const r = 90 + Math.random() * 140;
      const angle = (idx / PHRASES.length) * Math.PI * 2 + (Math.random() * 0.35);
      const y = (Math.random() - 0.5) * 30;

      sprite.position.set(
        Math.cos(angle) * r,
        y,
        Math.sin(angle) * r
      );

      sprite.userData.baseY = sprite.position.y;
      sprite.userData.floatSpeed = 0.6 + Math.random() * 0.8;
      sprite.userData.floatAmp = 0.6 + Math.random() * 1.0;

      phraseGroup.add(sprite);
    });

    // ---------------------------
    //  FOTO SPRITES (im√°genes reales)
    // ---------------------------
    const photoGroup = new THREE.Group();
    galaxy.add(photoGroup);

    const loader = new THREE.TextureLoader();
    loader.setCrossOrigin("anonymous");

    function makePhotoSprite(url, size = 12){
      const tex = loader.load(url);
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;

      const mat = new THREE.SpriteMaterial({
        map: tex,
        transparent: true,
        opacity: 0.95,
        depthWrite: false
      });

      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(size, size, 1);

      return sprite;
    }

    PHOTO_URLS.forEach((url, idx) => {
      const size = 10 + Math.random() * 6;
      const sprite = makePhotoSprite(url, size);

      const r = 70 + Math.random() * 110;
      const angle = (idx / PHOTO_URLS.length) * Math.PI * 2 + (Math.random() * 0.4);
      const y = (Math.random() - 0.5) * 26;

      sprite.position.set(
        Math.cos(angle) * r,
        y,
        Math.sin(angle) * r
      );

      sprite.userData.baseY = sprite.position.y;
      sprite.userData.floatSpeed = 0.7 + Math.random() * 0.7;
      sprite.userData.floatAmp = 0.8 + Math.random() * 1.4;

      // Guardamos posici√≥n original (para regresar)
      sprite.userData.homePos = sprite.position.clone();
      sprite.userData.homeScale = sprite.scale.clone();

      photoGroup.add(sprite);
    });

    // ---------------------------
    //  User controls (drag rotate + zoom)
    // ---------------------------
    let isDragging = false;
    let lastX = 0, lastY = 0;

    let targetRotY = 0;
    let targetRotX = 0;

    // Zoom control
    let targetZ = camera.position.z;
    const MIN_Z = 60;
    const MAX_Z = 280;

    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

    // Auto-rotation pause control
    let autoRotate = true;
    let lastUserInteraction = performance.now();
    const RESUME_DELAY = 900;

    function markInteraction(){
      lastUserInteraction = performance.now();
      autoRotate = false;
      updateToggleText();
    }

    function onDown(x, y){
      isDragging = true;
      lastX = x;
      lastY = y;
      markInteraction();
    }

    function onMove(x, y){
      if(!isDragging) return;

      const dx = x - lastX;
      const dy = y - lastY;

      lastX = x;
      lastY = y;

      targetRotY += dx * 0.005;
      targetRotX += dy * 0.003;

      targetRotX = clamp(targetRotX, -0.7, 0.7);

      markInteraction();
    }

    function onUp(){
      isDragging = false;
      markInteraction();
    }

    // Mouse
    window.addEventListener("mousedown", (e) => onDown(e.clientX, e.clientY));
    window.addEventListener("mousemove", (e) => onMove(e.clientX, e.clientY));
    window.addEventListener("mouseup", onUp);
    window.addEventListener("mouseleave", onUp);

    // Touch
    window.addEventListener("touchstart", (e) => {
      if(!e.touches || !e.touches[0]) return;
      onDown(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive:true });

    window.addEventListener("touchmove", (e) => {
      if(!e.touches || !e.touches[0]) return;
      onMove(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive:true });

    window.addEventListener("touchend", onUp);

    // Mouse wheel zoom
    window.addEventListener("wheel", (e) => {
      targetZ += e.deltaY * 0.08;
      targetZ = clamp(targetZ, MIN_Z, MAX_Z);
      markInteraction();
    }, { passive:true });

    // Pinch zoom
    let lastPinchDist = null;

    window.addEventListener("touchmove", (e) => {
      if(!e.touches || e.touches.length !== 2) {
        lastPinchDist = null;
        return;
      }

      const t0 = e.touches[0];
      const t1 = e.touches[1];

      const dx = t0.clientX - t1.clientX;
      const dy = t0.clientY - t1.clientY;
      const dist = Math.sqrt(dx*dx + dy*dy);

      if(lastPinchDist !== null){
        const delta = dist - lastPinchDist;
        targetZ -= delta * 0.15;
        targetZ = clamp(targetZ, MIN_Z, MAX_Z);
        markInteraction();
      }

      lastPinchDist = dist;
    }, { passive:true });

    // ---------------------------
    //  UI Buttons logic
    // ---------------------------
    const btnZoomIn = document.getElementById("zoomIn");
    const btnZoomOut = document.getElementById("zoomOut");
    const btnReset = document.getElementById("resetView");
    const btnToggle = document.getElementById("toggleAuto");
    const btnLove = document.getElementById("loveBtn");
    const statusText = document.getElementById("statusText");

    function updateToggleText(){
      btnToggle.textContent = autoRotate ? "Auto: ON" : "Auto: OFF";
      statusText.textContent = autoRotate ? "Modo suave üåô" : "Modo manual ‚úã";
    }

    btnZoomIn.addEventListener("click", () => {
      targetZ -= 18;
      targetZ = clamp(targetZ, MIN_Z, MAX_Z);
      markInteraction();
    });

    btnZoomOut.addEventListener("click", () => {
      targetZ += 18;
      targetZ = clamp(targetZ, MIN_Z, MAX_Z);
      markInteraction();
    });

    btnReset.addEventListener("click", () => {
      targetRotX = 0;
      targetRotY = 0;
      targetZ = 150;

      // tambi√©n regresamos la foto enfocada (si hab√≠a)
      focusedPhoto = null;
      focusLerp = 0;

      lastUserInteraction = performance.now();
      autoRotate = false;
      updateToggleText();
    });

    btnToggle.addEventListener("click", () => {
      autoRotate = !autoRotate;
      lastUserInteraction = performance.now();
      updateToggleText();
    });

    updateToggleText();

    // ---------------------------
    //  TE AMO: cambiar cielo (nuevo)
    // ---------------------------
    let loveMode = false;

    // Colores para el fog (nebula)
    const normalFog = new THREE.Color(0x4a86ff);
    const loveFog = new THREE.Color(0xff4fb1);

    // Para animar transici√≥n suave
    let fogMix = 0; // 0 normal, 1 love
    let fogTarget = 0;

    btnLove.addEventListener("click", () => {
      loveMode = !loveMode;
      fogTarget = loveMode ? 1 : 0;

      btnLove.textContent = loveMode ? "TE AMO üíó (ON)" : "TE AMO üíó";
      markInteraction();
    });

    // ---------------------------
    //  Click/Tap en fotos = zoom al centro (nuevo)
    // ---------------------------
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    let focusedPhoto = null;
    let focusLerp = 0; // 0 = normal, 1 = enfocada

    function setPointerFromEvent(e){
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / rect.width;
      const y = (e.clientY - rect.top) / rect.height;
      pointer.x = x * 2 - 1;
      pointer.y = -(y * 2 - 1);
    }

    function focusPhoto(sprite){
      focusedPhoto = sprite;
      focusLerp = 0; // arrancar transici√≥n
      autoRotate = false;
      lastUserInteraction = performance.now();
      updateToggleText();

      // zoom m√°s cerca para verla mejor
      targetZ = clamp(95, MIN_Z, MAX_Z);
    }

    function unfocusPhoto(){
      focusedPhoto = null;
      focusLerp = 0;
      targetZ = clamp(150, MIN_Z, MAX_Z);
    }

    function onTap(e){
      // si est√°s arrastrando, no cuenta como tap
      if(isDragging) return;

      setPointerFromEvent(e);

      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(photoGroup.children, true);

      if(hits.length > 0){
        const hit = hits[0].object;

        // si tocas la misma foto, se regresa
        if(focusedPhoto === hit){
          unfocusPhoto();
        }else{
          focusPhoto(hit);
        }
        markInteraction();
      }
    }

    // Click en PC
    window.addEventListener("click", (e) => onTap(e));

    // Tap en celular
    window.addEventListener("touchend", (e) => {
      if(!e.changedTouches || !e.changedTouches[0]) return;
      const t = e.changedTouches[0];
      onTap({ clientX: t.clientX, clientY: t.clientY });
    }, { passive:true });

    // ---------------------------
    //  Animate
    // ---------------------------
    const clock = new THREE.Clock();

    function animate(){
      const t = clock.getElapsedTime();

      // Reanudar auto-rotaci√≥n despu√©s de un tiempo sin interacci√≥n
      if(!isDragging){
        const now = performance.now();
        if(now - lastUserInteraction > RESUME_DELAY){
          autoRotate = true;
          updateToggleText();
        }
      }

      // Auto-rotaci√≥n MUY lenta (solo si no interact√∫as)
      if(autoRotate && !isDragging){
        targetRotY += 0.0006;
        targetRotX += Math.sin(t * 0.2) * 0.00002;
      }

      // Suavizado hacia el target
      galaxy.rotation.y += (targetRotY - galaxy.rotation.y) * 0.08;
      galaxy.rotation.x += (targetRotX - galaxy.rotation.x) * 0.08;

      // Zoom suave
      camera.position.z += (targetZ - camera.position.z) * 0.12;

      // Brillo leve
      starMat.opacity = 0.92 + Math.sin(t * 1.1) * 0.04;

      // Flotaci√≥n suave de frases
      phraseGroup.children.forEach((s) => {
        s.position.y = s.userData.baseY + Math.sin(t * s.userData.floatSpeed) * s.userData.floatAmp;
      });

      // Flotaci√≥n suave de fotos
      photoGroup.children.forEach((p) => {
        p.position.y = p.userData.baseY + Math.sin(t * p.userData.floatSpeed) * p.userData.floatAmp;
      });

      // ---------
      // TE AMO: transici√≥n suave de cielo (fog)
      // ---------
      fogMix += (fogTarget - fogMix) * 0.06;

      // Mezcla color
      const mixed = normalFog.clone().lerp(loveFog, fogMix);
      fogMat.color.copy(mixed);

      // Subimos opacidad en modo love
      const baseFog = 0.05;
      const extraFog = 0.05;
      fogMat.opacity = baseFog + extraFog * fogMix;

      // ---------
      // Focus en foto (zoom al centro)
      // ---------
      if(focusedPhoto){
        // transici√≥n suave
        focusLerp = Math.min(1, focusLerp + 0.03);

        // movemos la foto enfocada al centro
        const targetPos = new THREE.Vector3(0, 0, 0);

        focusedPhoto.position.lerp(targetPos, 0.10 * focusLerp);

        // la hacemos m√°s grande
        const bigScale = focusedPhoto.userData.homeScale.clone().multiplyScalar(2.1);
        focusedPhoto.scale.lerp(bigScale, 0.10 * focusLerp);

        // las dem√°s regresan a su lugar suavemente
        photoGroup.children.forEach((p) => {
          if(p === focusedPhoto) return;
          p.position.lerp(p.userData.homePos, 0.06);
          p.scale.lerp(p.userData.homeScale, 0.06);
          p.material.opacity += (0.55 - p.material.opacity) * 0.06;
        });

        // la enfocada m√°s visible
        focusedPhoto.material.opacity += (1.0 - focusedPhoto.material.opacity) * 0.08;

      }else{
        // si no hay foco, todas vuelven a su posici√≥n normal
        photoGroup.children.forEach((p) => {
          p.position.lerp(p.userData.homePos, 0.06);
          p.scale.lerp(p.userData.homeScale, 0.06);
          p.material.opacity += (0.95 - p.material.opacity) * 0.06;
        });
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    animate();

    // Resize
    window.addEventListener("resize", () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
